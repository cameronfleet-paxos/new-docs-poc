---
title: 'Create Identity for Brokerage Enrollment'
description: 'Step-by-step recipe to create a Person Identity, Account, and Profile for crypto brokerage services'
---

This recipe shows you how to create a Person Identity, Account, and Profile to enable crypto brokerage services for your users. This is the foundation for allowing users to buy, hold, and sell crypto assets.

## Prerequisites

- Paxos Dashboard access in Sandbox
- API Key with the following scopes:
  - `identity:read_identity`
  - `identity:read_account`
  - `identity:write_identity`
  - `identity:write_account`
  - `funding:read_profile`
  - `funding:write_profile`
  - `exchange:read_order`
  - `exchange:write_order`

## Step 1: Get Access Token

First, authenticate with the Paxos OAuth service to get an access token:

<CodeGroup>

```go main.go
package main

import (
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "net/url"
    "strings"
)

type TokenResponse struct {
    AccessToken string `json:"access_token"`
    ExpiresIn   int    `json:"expires_in"`
    Scope       string `json:"scope"`
    TokenType   string `json:"token_type"`
}

func getAccessToken(clientID, clientSecret string) (*TokenResponse, error) {
    data := url.Values{}
    data.Set("grant_type", "client_credentials")
    data.Set("client_id", clientID)
    data.Set("client_secret", clientSecret)
    data.Set("scope", "identity:read_identity identity:read_account identity:write_identity identity:write_account funding:read_profile funding:write_profile exchange:read_order exchange:write_order")

    req, err := http.NewRequest("POST", "https://oauth.sandbox.paxos.com/oauth2/token", strings.NewReader(data.Encode()))
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
    
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, err
    }
    
    var tokenResp TokenResponse
    err = json.Unmarshal(body, &tokenResp)
    if err != nil {
        return nil, err
    }
    
    return &tokenResp, nil
}
```

```python auth.py
import requests

def get_access_token(client_id, client_secret):
    """Get OAuth access token from Paxos"""
    
    url = "https://oauth.sandbox.paxos.com/oauth2/token"
    
    data = {
        'grant_type': 'client_credentials',
        'client_id': client_id,
        'client_secret': client_secret,
        'scope': 'identity:read_identity identity:read_account identity:write_identity identity:write_account funding:read_profile funding:write_profile exchange:read_order exchange:write_order'
    }
    
    response = requests.post(url, data=data)
    response.raise_for_status()
    
    token_data = response.json()
    return token_data['access_token']

# Usage
client_id = "your_client_id"
client_secret = "your_client_secret"
access_token = get_access_token(client_id, client_secret)
```

```javascript auth.js
const axios = require('axios');
const qs = require('querystring');

async function getAccessToken(clientId, clientSecret) {
  try {
    const data = qs.stringify({
      'grant_type': 'client_credentials',
      'client_id': clientId,
      'client_secret': clientSecret,
      'scope': 'identity:read_identity identity:read_account identity:write_identity identity:write_account funding:read_profile funding:write_profile exchange:read_order exchange:write_order'
    });

    const response = await axios.post(
      'https://oauth.sandbox.paxos.com/oauth2/token',
      data,
      {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    return response.data.access_token;
  } catch (error) {
    console.error('Error getting access token:', error.response?.data || error.message);
    throw error;
  }
}

// Usage
const clientId = 'your_client_id';
const clientSecret = 'your_client_secret';
getAccessToken(clientId, clientSecret)
  .then(token => console.log('Access Token:', token))
  .catch(err => console.error(err));
```

</CodeGroup>

Save the `access_token` from the response for use in subsequent requests.

## Step 2: Create Person Identity

Create an Identity with passthrough verification for your user:

<CodeGroup>

```go identity.go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

type PersonDetails struct {
    VerifierType                    string            `json:"verifier_type"`
    PassthroughVerifierType         string            `json:"passthrough_verifier_type"`
    PassthroughVerifiedAt          string            `json:"passthrough_verified_at"`
    PassthroughVerificationID      string            `json:"passthrough_verification_id"`
    PassthroughVerificationStatus  string            `json:"passthrough_verification_status"`
    PassthroughVerificationFields  []string          `json:"passthrough_verification_fields"`
    FirstName                      string            `json:"first_name"`
    LastName                       string            `json:"last_name"`
    DateOfBirth                    string            `json:"date_of_birth"`
    Address                        Address           `json:"address"`
    Nationality                    string            `json:"nationality"`
    CipID                          string            `json:"cip_id"`
    CipIDType                      string            `json:"cip_id_type"`
    CipIDCountry                   string            `json:"cip_id_country"`
    PhoneNumber                    string            `json:"phone_number"`
    Email                          string            `json:"email"`
}

type Address struct {
    Address1 string `json:"address1"`
    City     string `json:"city"`
    Province string `json:"province"`
    Country  string `json:"country"`
    ZipCode  string `json:"zip_code"`
}

type CustomerDueDiligence struct {
    EstimatedYearlyIncome      string `json:"estimated_yearly_income"`
    ExpectedTransferValue      string `json:"expected_transfer_value"`
    SourceOfWealth            string `json:"source_of_wealth"`
    EmploymentStatus          string `json:"employment_status"`
    EmploymentIndustrySector  string `json:"employment_industry_sector"`
}

type CreateIdentityRequest struct {
    RefID                   string               `json:"ref_id"`
    PersonDetails          PersonDetails        `json:"person_details"`
    CustomerDueDiligence   CustomerDueDiligence `json:"customer_due_diligence"`
}

func createIdentity(accessToken, refID string) error {
    request := CreateIdentityRequest{
        RefID: refID,
        PersonDetails: PersonDetails{
            VerifierType:                   "PASSTHROUGH",
            PassthroughVerifierType:        "JUMIO",
            PassthroughVerifiedAt:          "2021-06-16T09:28:14Z",
            PassthroughVerificationID:      "775300ef-4edb-47b9-8ec4-f45fe3cbf41f",
            PassthroughVerificationStatus:  "APPROVED",
            PassthroughVerificationFields:  []string{"FULL_LEGAL_NAME", "DATE_OF_BIRTH"},
            FirstName:    "Billy",
            LastName:     "Duncan",
            DateOfBirth:  "1960-01-01",
            Address: Address{
                Address1: "123 Main St",
                City:     "New York",
                Province: "NY",
                Country:  "USA",
                ZipCode:  "10001",
            },
            Nationality:   "USA",
            CipID:         "073-05-1120",
            CipIDType:     "SSN",
            CipIDCountry:  "USA",
            PhoneNumber:   "+1 555 678 1234",
            Email:         "example@somemail.org",
        },
        CustomerDueDiligence: CustomerDueDiligence{
            EstimatedYearlyIncome:     "INCOME_50K_TO_100K",
            ExpectedTransferValue:     "TRANSFER_VALUE_25K_TO_50K",
            SourceOfWealth:           "EMPLOYMENT_INCOME",
            EmploymentStatus:         "FULL_TIME",
            EmploymentIndustrySector: "ARTS_ENTERTAINMENT_RECREATION",
        },
    }

    jsonData, err := json.Marshal(request)
    if err != nil {
        return err
    }

    req, err := http.NewRequest("POST", "https://api.sandbox.paxos.com/v2/identity/identities", bytes.NewBuffer(jsonData))
    if err != nil {
        return err
    }

    req.Header.Set("Authorization", "Bearer "+accessToken)
    req.Header.Set("Content-Type", "application/json")

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    fmt.Printf("Identity creation status: %d\n", resp.StatusCode)
    return nil
}
```

```python identity.py
import requests
import json

def create_identity(access_token, ref_id):
    """Create a Person Identity with passthrough verification"""
    
    url = "https://api.sandbox.paxos.com/v2/identity/identities"
    
    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }
    
    data = {
        "ref_id": ref_id,
        "person_details": {
            "verifier_type": "PASSTHROUGH",
            "passthrough_verifier_type": "JUMIO",
            "passthrough_verified_at": "2021-06-16T09:28:14Z",
            "passthrough_verification_id": "775300ef-4edb-47b9-8ec4-f45fe3cbf41f",
            "passthrough_verification_status": "APPROVED",
            "passthrough_verification_fields": ["FULL_LEGAL_NAME", "DATE_OF_BIRTH"],
            "first_name": "Billy",
            "last_name": "Duncan",
            "date_of_birth": "1960-01-01",
            "address": {
                "address1": "123 Main St",
                "city": "New York",
                "province": "NY",
                "country": "USA",
                "zip_code": "10001"
            },
            "nationality": "USA",
            "cip_id": "073-05-1120",
            "cip_id_type": "SSN",
            "cip_id_country": "USA",
            "phone_number": "+1 555 678 1234",
            "email": "example@somemail.org"
        },
        "customer_due_diligence": {
            "estimated_yearly_income": "INCOME_50K_TO_100K",
            "expected_transfer_value": "TRANSFER_VALUE_25K_TO_50K",
            "source_of_wealth": "EMPLOYMENT_INCOME",
            "employment_status": "FULL_TIME",
            "employment_industry_sector": "ARTS_ENTERTAINMENT_RECREATION"
        }
    }
    
    response = requests.post(url, headers=headers, json=data)
    response.raise_for_status()
    
    identity_data = response.json()
    return identity_data

# Usage
identity = create_identity(access_token, "your_end_user_ref_id")
identity_id = identity['id']
print(f"Created identity: {identity_id}")
```

```javascript identity.js
const axios = require('axios');

async function createIdentity(accessToken, refId) {
  try {
    const data = {
      ref_id: refId,
      person_details: {
        verifier_type: "PASSTHROUGH",
        passthrough_verifier_type: "JUMIO",
        passthrough_verified_at: "2021-06-16T09:28:14Z",
        passthrough_verification_id: "775300ef-4edb-47b9-8ec4-f45fe3cbf41f",
        passthrough_verification_status: "APPROVED",
        passthrough_verification_fields: ["FULL_LEGAL_NAME", "DATE_OF_BIRTH"],
        first_name: "Billy",
        last_name: "Duncan",
        date_of_birth: "1960-01-01",
        address: {
          address1: "123 Main St",
          city: "New York",
          province: "NY",
          country: "USA",
          zip_code: "10001"
        },
        nationality: "USA",
        cip_id: "073-05-1120",
        cip_id_type: "SSN",
        cip_id_country: "USA",
        phone_number: "+1 555 678 1234",
        email: "example@somemail.org"
      },
      customer_due_diligence: {
        estimated_yearly_income: "INCOME_50K_TO_100K",
        expected_transfer_value: "TRANSFER_VALUE_25K_TO_50K",
        source_of_wealth: "EMPLOYMENT_INCOME",
        employment_status: "FULL_TIME",
        employment_industry_sector: "ARTS_ENTERTAINMENT_RECREATION"
      }
    };

    const response = await axios.post(
      'https://api.sandbox.paxos.com/v2/identity/identities',
      data,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        }
      }
    );

    return response.data;
  } catch (error) {
    console.error('Error creating identity:', error.response?.data || error.message);
    throw error;
  }
}

// Usage
createIdentity(accessToken, 'your_end_user_ref_id')
  .then(identity => {
    console.log('Created identity:', identity.id);
    return identity.id;
  })
  .catch(err => console.error(err));
```

</CodeGroup>

<Note>
The `cip_id` must be unique across all identities. If you receive a `409 duplicate cip_id` error, either refuse service or create a new Account for the existing Identity.
</Note>

## Step 3: Check Identity Status

Wait for the Identity to be approved by checking its status:

<CodeGroup>

```go status.go
func getIdentityStatus(accessToken, identityID string) error {
    req, err := http.NewRequest("GET", 
        fmt.Sprintf("https://api.sandbox.paxos.com/v2/identity/identities/%s", identityID), 
        nil)
    if err != nil {
        return err
    }

    req.Header.Set("Authorization", "Bearer "+accessToken)

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return err
    }

    fmt.Printf("Identity status response: %s\n", string(body))
    return nil
}
```

```python status.py
def get_identity_status(access_token, identity_id):
    """Check the status of an Identity"""
    
    url = f"https://api.sandbox.paxos.com/v2/identity/identities/{identity_id}"
    
    headers = {
        "Authorization": f"Bearer {access_token}"
    }
    
    response = requests.get(url, headers=headers)
    response.raise_for_status()
    
    identity_data = response.json()
    return identity_data['summary_status']

# Usage
status = get_identity_status(access_token, identity_id)
print(f"Identity status: {status}")
```

```javascript status.js
async function getIdentityStatus(accessToken, identityId) {
  try {
    const response = await axios.get(
      `https://api.sandbox.paxos.com/v2/identity/identities/${identityId}`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    return response.data.summary_status;
  } catch (error) {
    console.error('Error getting identity status:', error.response?.data || error.message);
    throw error;
  }
}

// Usage
const status = await getIdentityStatus(accessToken, identityId);
console.log('Identity status:', status);
```

</CodeGroup>

The `summary_status` should be `APPROVED` for the next step.

## Step 4: Create Account and Profile

Create a brokerage account and profile for the approved Identity:

<CodeGroup>

```go account.go
type CreateAccountRequest struct {
    CreateProfile bool    `json:"create_profile"`
    Account      Account `json:"account"`
}

type Account struct {
    IdentityID  string `json:"identity_id"`
    RefID       string `json:"ref_id"`
    Type        string `json:"type"`
    Description string `json:"description"`
}

func createAccount(accessToken, identityID, accountRefID string) error {
    request := CreateAccountRequest{
        CreateProfile: true,
        Account: Account{
            IdentityID:  identityID,
            RefID:       accountRefID,
            Type:        "BROKERAGE",
            Description: "Brokerage account for Billy Duncan",
        },
    }

    jsonData, err := json.Marshal(request)
    if err != nil {
        return err
    }

    req, err := http.NewRequest("POST", "https://api.sandbox.paxos.com/v2/identity/accounts", bytes.NewBuffer(jsonData))
    if err != nil {
        return err
    }

    req.Header.Set("Authorization", "Bearer "+accessToken)
    req.Header.Set("Content-Type", "application/json")

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    fmt.Printf("Account creation status: %d\n", resp.StatusCode)
    return nil
}
```

```python account.py
def create_account(access_token, identity_id, account_ref_id):
    """Create a brokerage account and profile"""
    
    url = "https://api.sandbox.paxos.com/v2/identity/accounts"
    
    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }
    
    data = {
        "create_profile": True,
        "account": {
            "identity_id": identity_id,
            "ref_id": account_ref_id,
            "type": "BROKERAGE",
            "description": "Brokerage account for Billy Duncan"
        }
    }
    
    response = requests.post(url, headers=headers, json=data)
    response.raise_for_status()
    
    account_data = response.json()
    return account_data

# Usage
account = create_account(access_token, identity_id, "your_account_ref")
account_id = account['id']
profile_id = account['profile_id']
print(f"Created account: {account_id}")
print(f"Created profile: {profile_id}")
```

```javascript account.js
async function createAccount(accessToken, identityId, accountRefId) {
  try {
    const data = {
      create_profile: true,
      account: {
        identity_id: identityId,
        ref_id: accountRefId,
        type: "BROKERAGE",
        description: "Brokerage account for Billy Duncan"
      }
    };

    const response = await axios.post(
      'https://api.sandbox.paxos.com/v2/identity/accounts',
      data,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        }
      }
    );

    return response.data;
  } catch (error) {
    console.error('Error creating account:', error.response?.data || error.message);
    throw error;
  }
}

// Usage
const account = await createAccount(accessToken, identityId, 'your_account_ref');
const accountId = account.id;
const profileId = account.profile_id;
console.log('Created account:', accountId);
console.log('Created profile:', profileId);
```

</CodeGroup>

<Info>
Setting `create_profile: true` automatically creates a Profile for the Account, which is required for Fiat and Crypto Subledger integrations.
</Info>

## Step 5: Fund the Account (Sandbox Only)

For testing in sandbox, you can use the Dashboard's Test Funds feature:

1. Navigate to the [Paxos Dashboard](https://dashboard.sandbox.paxos.com/)
2. Click the "Fund" button
3. Select your Profile and fund with $10,000 USD

## Step 6: Place Your First Order

You can now place orders using the created Identity, Account, and Profile:

<CodeGroup>

```go order.go
type CreateOrderRequest struct {
    Side               string `json:"side"`
    Market            string `json:"market"`
    Type              string `json:"type"`
    Price             string `json:"price"`
    BaseAmount        string `json:"base_amount"`
    IdentityID        string `json:"identity_id"`
    IdentityAccountID string `json:"identity_account_id"`
}

func createOrder(accessToken, profileID, identityID, accountID string) error {
    request := CreateOrderRequest{
        Side:               "BUY",
        Market:            "ETHUSD",
        Type:              "LIMIT",
        Price:             "1814.8",
        BaseAmount:        "1",
        IdentityID:        identityID,
        IdentityAccountID: accountID,
    }

    jsonData, err := json.Marshal(request)
    if err != nil {
        return err
    }

    url := fmt.Sprintf("https://api.sandbox.paxos.com/v2/profiles/%s/orders", profileID)
    req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
    if err != nil {
        return err
    }

    req.Header.Set("Authorization", "Bearer "+accessToken)
    req.Header.Set("Content-Type", "application/json")

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    fmt.Printf("Order creation status: %d\n", resp.StatusCode)
    return nil
}
```

```python order.py
def create_order(access_token, profile_id, identity_id, account_id, side="BUY"):
    """Create a buy or sell order"""
    
    url = f"https://api.sandbox.paxos.com/v2/profiles/{profile_id}/orders"
    
    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }
    
    data = {
        "side": side,
        "market": "ETHUSD",
        "type": "LIMIT",
        "price": "1814.8" if side == "BUY" else "1804.2",
        "base_amount": "1",
        "identity_id": identity_id,
        "identity_account_id": account_id
    }
    
    response = requests.post(url, headers=headers, json=data)
    response.raise_for_status()
    
    order_data = response.json()
    return order_data

# Usage - Buy Order
buy_order = create_order(access_token, profile_id, identity_id, account_id, "BUY")
print(f"Created buy order: {buy_order['id']}")

# Usage - Sell Order  
sell_order = create_order(access_token, profile_id, identity_id, account_id, "SELL")
print(f"Created sell order: {sell_order['id']}")
```

```javascript order.js
async function createOrder(accessToken, profileId, identityId, accountId, side = 'BUY') {
  try {
    const data = {
      side: side,
      market: "ETHUSD",
      type: "LIMIT",
      price: side === 'BUY' ? "1814.8" : "1804.2",
      base_amount: "1",
      identity_id: identityId,
      identity_account_id: accountId
    };

    const response = await axios.post(
      `https://api.sandbox.paxos.com/v2/profiles/${profileId}/orders`,
      data,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        }
      }
    );

    return response.data;
  } catch (error) {
    console.error('Error creating order:', error.response?.data || error.message);
    throw error;
  }
}

// Usage - Buy Order
const buyOrder = await createOrder(accessToken, profileId, identityId, accountId, 'BUY');
console.log('Created buy order:', buyOrder.id);

// Usage - Sell Order
const sellOrder = await createOrder(accessToken, profileId, identityId, accountId, 'SELL');
console.log('Created sell order:', sellOrder.id);
```

</CodeGroup>

## Result

You now have:
- ✅ A verified Person Identity
- ✅ A brokerage Account linked to the Identity  
- ✅ A Profile for holding fiat and crypto assets
- ✅ The ability to place buy/sell orders

Your user can now buy, hold, and sell crypto assets through your brokerage integration.

## Next Steps

- Set up [Fiat Transfers](/developer/fiat-transfers/quickstart) for real funding
- Implement [Webhooks](/webhooks) for real-time status updates
- Explore [FIX](/fix) or [WebSocket](/api/websocket) APIs for advanced trading 